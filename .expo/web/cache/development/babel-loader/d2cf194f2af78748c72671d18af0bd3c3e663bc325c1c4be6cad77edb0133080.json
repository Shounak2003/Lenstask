{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nvar _excluded = [\"screen\", \"if\"],\n  _excluded2 = [\"screens\", \"groups\"],\n  _excluded3 = [\"if\"];\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nimport * as React from 'react';\nimport { useRoute } from \"./useRoute\";\nvar MemoizedScreen = React.memo(function (_ref) {\n  var component = _ref.component;\n  var route = useRoute();\n  var children = React.createElement(component, {\n    route: route\n  });\n  return children;\n});\nvar getItemsFromScreens = function getItemsFromScreens(Screen, screens) {\n  return Object.entries(screens).map(function (_ref2) {\n    var _ref6 = _slicedToArray(_ref2, 2),\n      name = _ref6[0],\n      item = _ref6[1];\n    var component;\n    var props = {};\n    var useIf;\n    var isNavigator = false;\n    if ('screen' in item) {\n      var screen = item.screen,\n        _if = item.if,\n        rest = _objectWithoutProperties(item, _excluded);\n      useIf = _if;\n      props = rest;\n      if (typeof screen === 'function') {\n        component = screen;\n      } else if ('config' in screen) {\n        isNavigator = true;\n        component = createComponentForStaticNavigation(screen, `${name}Navigator`);\n      }\n    } else if (typeof item === 'function') {\n      component = item;\n    } else if ('config' in item) {\n      isNavigator = true;\n      component = createComponentForStaticNavigation(item, `${name}Navigator`);\n    }\n    if (component == null) {\n      throw new Error(`Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`);\n    }\n    var element = isNavigator ? React.createElement(component, {}) : React.createElement(MemoizedScreen, {\n      component: component\n    });\n    return function () {\n      var shouldRender = useIf == null || useIf();\n      if (!shouldRender) {\n        return null;\n      }\n      return React.createElement(Screen, _extends({\n        key: name,\n        name: name\n      }, props), function () {\n        return element;\n      });\n    };\n  });\n};\nexport function createComponentForStaticNavigation(tree, displayName) {\n  var Navigator = tree.Navigator,\n    Group = tree.Group,\n    Screen = tree.Screen,\n    config = tree.config;\n  var screens = config.screens,\n    groups = config.groups,\n    rest = _objectWithoutProperties(config, _excluded2);\n  var items = getItemsFromScreens(Screen, screens);\n  if (groups) {\n    items.push.apply(items, _toConsumableArray(Object.entries(groups).map(function (_ref3) {\n      var _ref7 = _slicedToArray(_ref3, 2),\n        key = _ref7[0],\n        _ref7$ = _ref7[1],\n        useIf = _ref7$.if,\n        group = _objectWithoutProperties(_ref7$, _excluded3);\n      var groupItems = getItemsFromScreens(Screen, group.screens);\n      return function () {\n        var children = groupItems.map(function (item) {\n          return item();\n        });\n        var shouldRender = useIf == null || useIf();\n        if (!shouldRender) {\n          return null;\n        }\n        return React.createElement(Group, _extends({\n          navigationKey: key\n        }, group, {\n          key: key\n        }), children);\n      };\n    })));\n  }\n  var NavigatorComponent = function NavigatorComponent() {\n    var children = items.map(function (item) {\n      return item();\n    });\n    return React.createElement(Navigator, rest, children);\n  };\n  NavigatorComponent.displayName = displayName;\n  return NavigatorComponent;\n}\nexport function createPathConfigForStaticNavigation(tree) {\n  return Object.fromEntries(Object.entries(tree.config.screens).map(function (_ref4) {\n    var _ref8 = _slicedToArray(_ref4, 2),\n      key = _ref8[0],\n      item = _ref8[1];\n    var screenConfig = {};\n    if ('linking' in item) {\n      if (typeof item.linking === 'string') {\n        screenConfig.path = item.linking;\n      } else {\n        Object.assign(screenConfig, item.linking);\n      }\n    }\n    if ('config' in item) {\n      screenConfig.screens = createPathConfigForStaticNavigation(item);\n    } else if ('screen' in item && 'config' in item.screen && item.screen.config.screens) {\n      screenConfig.screens = createPathConfigForStaticNavigation(item.screen);\n    }\n    return [key, screenConfig];\n  }).filter(function (_ref5) {\n    var _ref9 = _slicedToArray(_ref5, 2),\n      screen = _ref9[1];\n    return Object.keys(screen).length > 0;\n  }));\n}","map":{"version":3,"names":["React","useRoute","MemoizedScreen","memo","_ref","component","route","children","createElement","getItemsFromScreens","Screen","screens","Object","entries","map","_ref2","_ref6","_slicedToArray","name","item","props","useIf","isNavigator","screen","_if","if","rest","_objectWithoutProperties","_excluded","createComponentForStaticNavigation","Error","element","shouldRender","_extends","key","tree","displayName","Navigator","Group","config","groups","_excluded2","items","push","apply","_toConsumableArray","_ref3","_ref7","_ref7$","group","_excluded3","groupItems","navigationKey","NavigatorComponent","createPathConfigForStaticNavigation","fromEntries","_ref4","_ref8","screenConfig","linking","path","assign","filter","_ref5","_ref9","keys","length"],"sources":["/home/shounak/Desktop/Letsgo/new/web3-cross-platform-lens/node_modules/@react-navigation/core/src/StaticNavigation.tsx"],"sourcesContent":["import type { NavigationState, ParamListBase } from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport type {\n  DefaultNavigatorOptions,\n  EventMapBase,\n  NavigatorScreenParams,\n  PathConfig,\n  RouteConfig,\n  RouteGroupConfig,\n} from './types';\nimport { useRoute } from './useRoute';\n\n/**\n * Flatten a type to remove all type alias names, unions etc.\n * This will show a plain object when hovering over the type.\n */\ntype FlatType<T> = { [K in keyof T]: T[K] } & {};\n\n/**\n * keyof T doesn't work for union types. We can use distributive conditional types instead.\n * https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n */\ntype KeysOf<T> = T extends {} ? keyof T : never;\n\n/**\n * We get a union type when using keyof, but we want an intersection instead.\n * https://stackoverflow.com/a/50375286/1665026\n */\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I\n) => void\n  ? I\n  : never;\n\ntype UnknownToUndefined<T> = unknown extends T ? undefined : T;\n\ntype ParamsForScreenComponent<T> = T extends {\n  screen: React.ComponentType<{ route: { params: infer P } }>;\n}\n  ? P\n  : T extends React.ComponentType<{ route: { params: infer P } }>\n  ? P\n  : undefined;\n\ntype ParamsForScreen<T> = T extends { screen: StaticNavigation<any, any, any> }\n  ? NavigatorScreenParams<StaticParamList<T['screen']>> | undefined\n  : T extends StaticNavigation<any, any, any>\n  ? NavigatorScreenParams<StaticParamList<T>> | undefined\n  : UnknownToUndefined<ParamsForScreenComponent<T>>;\n\ntype ParamListForScreens<Screens> = {\n  [Key in KeysOf<Screens>]: ParamsForScreen<Screens[Key]>;\n};\n\ntype ParamListForGroups<\n  Groups extends\n    | Readonly<{\n        [key: string]: {\n          screens: StaticConfigScreens<\n            ParamListBase,\n            NavigationState,\n            {},\n            EventMapBase\n          >;\n        };\n      }>\n    | undefined,\n> = Groups extends {\n  [key: string]: {\n    screens: StaticConfigScreens<\n      ParamListBase,\n      NavigationState,\n      {},\n      EventMapBase\n    >;\n  };\n}\n  ? ParamListForScreens<UnionToIntersection<Groups[keyof Groups]['screens']>>\n  : {};\n\ntype StaticConfigScreens<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n> = {\n  [key in keyof ParamList]:\n    | React.ComponentType<any>\n    | StaticNavigation<any, any, any>\n    | (Omit<\n        RouteConfig<ParamList, keyof ParamList, State, ScreenOptions, EventMap>,\n        'name' | 'component' | 'getComponent' | 'children'\n      > & {\n        /**\n         * Callback to determine whether the screen should be rendered or not.\n         * This can be useful for conditional rendering of screens,\n         * e.g. - if you want to render a different screen for logged in users.\n         *\n         * You can use a custom hook to use custom logic to determine the return value.\n         *\n         * @example\n         * ```js\n         * if: useIsLoggedIn\n         * ```\n         */\n        if?: () => boolean;\n        /**\n         * Linking config for the screen.\n         * This can be a string to specify the path, or an object with more options.\n         *\n         * @example\n         * ```js\n         * linking: {\n         *   path: 'profile/:id',\n         *   exact: true,\n         * },\n         * ```\n         */\n        linking?: PathConfig<ParamList> | string;\n        /**\n         * Static navigation config or Component to render for the screen.\n         */\n        screen: StaticNavigation<any, any, any> | React.ComponentType<any>;\n      });\n};\n\ntype GroupConfig<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n> = Omit<RouteGroupConfig<ParamList, ScreenOptions>, 'screens' | 'children'> & {\n  /**\n   * Callback to determine whether the screens in the group should be rendered or not.\n   * This can be useful for conditional rendering of group of screens.\n   */\n  if?: () => boolean;\n  /**\n   * Static navigation config or Component to render for the screen.\n   */\n  screens: StaticConfigScreens<ParamList, State, ScreenOptions, EventMap>;\n};\n\nexport type StaticConfig<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  Navigator extends React.ComponentType<{}>,\n> = Omit<\n  Omit<\n    React.ComponentProps<Navigator>,\n    keyof DefaultNavigatorOptions<\n      ParamListBase,\n      NavigationState,\n      {},\n      EventMapBase\n    >\n  > &\n    DefaultNavigatorOptions<ParamList, State, ScreenOptions, EventMap>,\n  'screens' | 'children'\n> & {\n  /**\n   * Screens to render in the navigator and their configuration.\n   */\n  screens: StaticConfigScreens<ParamList, State, ScreenOptions, EventMap>;\n  /**\n   * Groups of screens to render in the navigator and their configuration.\n   */\n  groups?: {\n    [key: string]: GroupConfig<ParamList, State, ScreenOptions, EventMap>;\n  };\n};\n\n/**\n * Props for a screen component which is rendered by a static navigator.\n * Takes the route params as a generic argument.\n */\nexport type StaticScreenProps<T extends Record<string, unknown> | undefined> = {\n  route: {\n    params: T;\n  };\n};\n\n/**\n * Infer the param list from the static navigation config.\n */\nexport type StaticParamList<\n  T extends {\n    readonly config: {\n      readonly screens: Record<string, any>;\n      readonly groups?: {\n        [key: string]: {\n          screens: Record<string, any>;\n        };\n      };\n    };\n  },\n> = FlatType<\n  ParamListForScreens<T['config']['screens']> &\n    ParamListForGroups<T['config']['groups']>\n>;\n\nexport type StaticNavigation<NavigatorProps, GroupProps, ScreenProps> = {\n  Navigator: React.ComponentType<NavigatorProps>;\n  Group: React.ComponentType<GroupProps>;\n  Screen: React.ComponentType<ScreenProps>;\n  config: StaticConfig<\n    ParamListBase,\n    NavigationState,\n    {},\n    EventMapBase,\n    React.ComponentType<any>\n  >;\n};\n\nconst MemoizedScreen = React.memo(\n  <T extends React.ComponentType<any>>({ component }: { component: T }) => {\n    const route = useRoute();\n    const children = React.createElement(component, { route });\n\n    return children;\n  }\n);\n\nconst getItemsFromScreens = (\n  Screen: React.ComponentType<any>,\n  screens: StaticConfigScreens<any, any, any, any>\n) => {\n  return Object.entries(screens).map(([name, item]) => {\n    let component: React.ComponentType<any> | undefined;\n    let props: {} = {};\n    let useIf: (() => boolean) | undefined;\n\n    let isNavigator = false;\n\n    if ('screen' in item) {\n      const { screen, if: _if, ...rest } = item;\n\n      useIf = _if;\n      props = rest;\n\n      if (typeof screen === 'function') {\n        component = screen;\n      } else if ('config' in screen) {\n        isNavigator = true;\n        component = createComponentForStaticNavigation(\n          screen,\n          `${name}Navigator`\n        );\n      }\n    } else if (typeof item === 'function') {\n      component = item;\n    } else if ('config' in item) {\n      isNavigator = true;\n      component = createComponentForStaticNavigation(item, `${name}Navigator`);\n    }\n\n    if (component == null) {\n      throw new Error(\n        `Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`\n      );\n    }\n\n    const element = isNavigator ? (\n      React.createElement(component, {})\n    ) : (\n      <MemoizedScreen component={component} />\n    );\n\n    return () => {\n      const shouldRender = useIf == null || useIf();\n\n      if (!shouldRender) {\n        return null;\n      }\n\n      return (\n        <Screen key={name} name={name} {...props}>\n          {() => element}\n        </Screen>\n      );\n    };\n  });\n};\n\n/**\n * Create a component that renders a navigator based on the static configuration.\n *\n * @param tree Static navigation config.\n * @param displayName Name of the component to be displayed in React DevTools.\n * @returns A component which renders the navigator.\n */\nexport function createComponentForStaticNavigation(\n  tree: StaticNavigation<any, any, any>,\n  displayName: string\n): React.ComponentType<{}> {\n  const { Navigator, Group, Screen, config } = tree;\n  const { screens, groups, ...rest } = config;\n\n  const items = getItemsFromScreens(Screen, screens);\n\n  if (groups) {\n    items.push(\n      ...Object.entries(groups).map(([key, { if: useIf, ...group }]) => {\n        const groupItems = getItemsFromScreens(Screen, group.screens);\n\n        return () => {\n          // Call unconditionally since screen configs may contain `useIf` hooks\n          const children = groupItems.map((item) => item());\n\n          const shouldRender = useIf == null || useIf();\n\n          if (!shouldRender) {\n            return null;\n          }\n\n          return (\n            <Group navigationKey={key} {...group} key={key}>\n              {children}\n            </Group>\n          );\n        };\n      })\n    );\n  }\n\n  const NavigatorComponent = () => {\n    const children = items.map((item) => item());\n\n    return <Navigator {...rest}>{children}</Navigator>;\n  };\n\n  NavigatorComponent.displayName = displayName;\n\n  return NavigatorComponent;\n}\n\n/**\n * Create a path config object from a static navigation config for deep linking.\n *\n * @param tree Static navigation config.\n * @returns Path config object to use in linking config.\n *\n * @example\n * ```js\n * const config = {\n *   screens: {\n *     Home: {\n *       screens: createPathConfigForStaticNavigation(HomeTabs),\n *     },\n *   },\n * };\n * ```\n */\nexport function createPathConfigForStaticNavigation(tree: {\n  config: {\n    screens: StaticConfigScreens<\n      ParamListBase,\n      NavigationState,\n      {},\n      EventMapBase\n    >;\n  };\n}) {\n  return Object.fromEntries(\n    Object.entries(tree.config.screens)\n      .map(([key, item]) => {\n        const screenConfig: PathConfig<ParamListBase> = {};\n\n        if ('linking' in item) {\n          if (typeof item.linking === 'string') {\n            screenConfig.path = item.linking;\n          } else {\n            Object.assign(screenConfig, item.linking);\n          }\n        }\n\n        if ('config' in item) {\n          screenConfig.screens = createPathConfigForStaticNavigation(item);\n        } else if (\n          'screen' in item &&\n          'config' in item.screen &&\n          item.screen.config.screens\n        ) {\n          screenConfig.screens = createPathConfigForStaticNavigation(\n            item.screen\n          );\n        }\n\n        return [key, screenConfig] as const;\n      })\n      .filter(([, screen]) => Object.keys(screen).length > 0)\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}